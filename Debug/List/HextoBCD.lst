###############################################################################
#
# IAR C/C++ Compiler V7.12.3.989/W32 for MSP430           24/Apr/2020  12:34:17
# Copyright 1996-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.12
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\HextoBCD.c
#    Command line  =  
#        -f C:\Users\laure\AppData\Local\Temp\EWEBCD.tmp
#        ("C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\HextoBCD.c" -lC
#        "C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\List" -o
#        "C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --debug -D__MSP430FR2355__ -e --double=32
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\430\lib\dlib\dl430xlsfn.h" -I ./\ --core=430X --data_model=small
#        -On --multiplier=32 --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\List\HextoBCD.lst
#    Object file   =  
#        C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\Obj\HextoBCD.r43
#
###############################################################################

C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code Submission\HextoBCD.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the conversion from HEX to BCD function
      4          //
      5          //
      6          //  Lauren Crawford
      7          //  02/28/2020
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
      9          //------------------------------------------------------------------------------
     10          
     11          #include  "functions.h"
     12          #include  "msp430.h"
     13          #include <string.h>
     14          #include "macros.h"
     15          
     16          extern char display_line[HEIGHTFOUR][ELEVENTH_CHARACTER];
     17          extern volatile unsigned char display_changed;
     18          extern volatile unsigned char update_display;
     19          extern volatile unsigned int update_display_count;
     20          
     21          
     22          // globals

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          char thousands;
   \                     thousands:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          char hundreds;
   \                     hundreds:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          char tens;
   \                     tens:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          char ones;
   \                     ones:
   \   000000                DS8 1
     27          

   \                                 In  segment CODE, align 2
     28          void HEXtoBCD_RIGHT(unsigned int value_passed){
   \                     HEXtoBCD_RIGHT:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
     29            thousands = RESET_STATE;
   \   000004   C243....     MOV.B   #0x0, &thousands
     30            hundreds = RESET_STATE;
   \   000008   C243....     MOV.B   #0x0, &hundreds
     31            tens = RESET_STATE;
   \   00000C   C243....     MOV.B   #0x0, &tens
     32            ones = RESET_STATE;
   \   000010   C243....     MOV.B   #0x0, &ones
     33            if(value_passed >= thousand){
   \   000014   3A90E803     CMP.W   #0x3e8, R10
   \   000018   0428         JNC     ??HEXtoBCD_RIGHT_0
     34              value_passed = value_passed - thousand;
   \   00001A   3A5018FC     ADD.W   #0xfc18, R10
     35              thousands = one;
   \   00001E   D243....     MOV.B   #0x1, &thousands
     36            }  
     37            while(value_passed >= hundred){
   \                     ??HEXtoBCD_RIGHT_0:
   \   000022   3A906400     CMP.W   #0x64, R10
   \   000026   0528         JNC     ??HEXtoBCD_RIGHT_1
     38              value_passed = value_passed - hundred;
   \   000028   3A509CFF     ADD.W   #0xff9c, R10
     39              hundreds = hundreds + one;
   \   00002C   D253....     ADD.B   #0x1, &hundreds
   \   000030   F83F         JMP     ??HEXtoBCD_RIGHT_0
     40            }
     41            while(value_passed >= ten){
   \                     ??HEXtoBCD_RIGHT_1:
   \   000032   3A900A00     CMP.W   #0xa, R10
   \   000036   0528         JNC     ??HEXtoBCD_RIGHT_2
     42              value_passed = value_passed - ten;
   \   000038   3A50F6FF     ADD.W   #0xfff6, R10
     43              tens = tens + one;
   \   00003C   D253....     ADD.B   #0x1, &tens
   \   000040   F83F         JMP     ??HEXtoBCD_RIGHT_1
     44            }
     45            while(value_passed >= one){
   \                     ??HEXtoBCD_RIGHT_2:
   \   000042   0A93         CMP.W   #0x0, R10
   \   000044   0424         JEQ     ??HEXtoBCD_RIGHT_3
     46              value_passed = value_passed - one;
   \   000046   3A53         ADD.W   #0xffff, R10
     47              ones = ones + one;
   \   000048   D253....     ADD.B   #0x1, &ones
   \   00004C   FA3F         JMP     ??HEXtoBCD_RIGHT_2
     48            }
     49            thousands |= offset;
   \                     ??HEXtoBCD_RIGHT_3:
   \   00004E   F2D03000.... BIS.B   #0x30, &thousands
     50            hundreds |= offset;
   \   000054   F2D03000.... BIS.B   #0x30, &hundreds
     51            tens |= offset;
   \   00005A   F2D03000.... BIS.B   #0x30, &tens
     52            ones |= offset;
   \   000060   F2D03000.... BIS.B   #0x30, &ones
     53            
     54              display_line[LINETHREE][LINETHREE]= thousands;
   \   000066   D242........ MOV.B   &thousands, &display_line + 36
     55              display_line[LINETHREE][HEIGHTFOUR] = hundreds;
   \   00006C   D242........ MOV.B   &hundreds, &display_line + 37
     56              display_line[LINETHREE][HEIGHTFIVE] = tens;
   \   000072   D242........ MOV.B   &tens, &display_line + 38
     57              display_line[LINETHREE][HEIGHTSIX] = ones;
   \   000078   D242........ MOV.B   &ones, &display_line + 39
     58              update_string(display_line[LINETHREE], LINETHREE);
   \   00007E   3D400300     MOV.W   #0x3, R13
   \   000082   3C40....     MOV.W   #display_line + 33, R12
   \   000086   ........     CALLA   #update_string
     59              
     60           }
   \   00008A   3A41         POP.W   R10
   \   00008C   1001         RETA

   \                                 In  segment CODE, align 2
     61          void HEXtoBCD_LEFT(unsigned int value_passed){
   \                     HEXtoBCD_LEFT:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
     62            thousands = RESET_STATE;
   \   000004   C243....     MOV.B   #0x0, &thousands
     63            hundreds = RESET_STATE;
   \   000008   C243....     MOV.B   #0x0, &hundreds
     64            tens = RESET_STATE;
   \   00000C   C243....     MOV.B   #0x0, &tens
     65            ones = RESET_STATE;
   \   000010   C243....     MOV.B   #0x0, &ones
     66            if(value_passed >= thousand){
   \   000014   3A90E803     CMP.W   #0x3e8, R10
   \   000018   0428         JNC     ??HEXtoBCD_LEFT_0
     67              value_passed = value_passed - thousand;
   \   00001A   3A5018FC     ADD.W   #0xfc18, R10
     68              thousands = one;
   \   00001E   D243....     MOV.B   #0x1, &thousands
     69            }  
     70            while(value_passed >= hundred){
   \                     ??HEXtoBCD_LEFT_0:
   \   000022   3A906400     CMP.W   #0x64, R10
   \   000026   0528         JNC     ??HEXtoBCD_LEFT_1
     71              value_passed = value_passed - hundred;
   \   000028   3A509CFF     ADD.W   #0xff9c, R10
     72              hundreds = hundreds + one;
   \   00002C   D253....     ADD.B   #0x1, &hundreds
   \   000030   F83F         JMP     ??HEXtoBCD_LEFT_0
     73            }
     74            while(value_passed >= ten){
   \                     ??HEXtoBCD_LEFT_1:
   \   000032   3A900A00     CMP.W   #0xa, R10
   \   000036   0528         JNC     ??HEXtoBCD_LEFT_2
     75              value_passed = value_passed - ten;
   \   000038   3A50F6FF     ADD.W   #0xfff6, R10
     76              tens = tens + one;
   \   00003C   D253....     ADD.B   #0x1, &tens
   \   000040   F83F         JMP     ??HEXtoBCD_LEFT_1
     77            }
     78            while(value_passed >= one){
   \                     ??HEXtoBCD_LEFT_2:
   \   000042   0A93         CMP.W   #0x0, R10
   \   000044   0424         JEQ     ??HEXtoBCD_LEFT_3
     79              value_passed = value_passed - one;
   \   000046   3A53         ADD.W   #0xffff, R10
     80              ones = ones + one;
   \   000048   D253....     ADD.B   #0x1, &ones
   \   00004C   FA3F         JMP     ??HEXtoBCD_LEFT_2
     81            }
     82            thousands |= offset;
   \                     ??HEXtoBCD_LEFT_3:
   \   00004E   F2D03000.... BIS.B   #0x30, &thousands
     83            hundreds |= offset;
   \   000054   F2D03000.... BIS.B   #0x30, &hundreds
     84            tens |= offset;
   \   00005A   F2D03000.... BIS.B   #0x30, &tens
     85            ones |= offset;
   \   000060   F2D03000.... BIS.B   #0x30, &ones
     86            
     87              display_line[LINEZERO][7] = ones;
   \   000066   D242........ MOV.B   &ones, &display_line + 7
     88              update_string(display_line[LINEZERO], LINEZERO);
   \   00006C   0D43         MOV.W   #0x0, R13
   \   00006E   3C40....     MOV.W   #display_line, R12
   \   000072   ........     CALLA   #update_string
     89              
     90           }
   \   000076   3A41         POP.W   R10
   \   000078   1001         RETA
     91          
     92          

   \                                 In  segment CODE, align 2
     93          void adc_line4(void){
   \                     adc_line4:
     94            }
   \   000000   1001         RETA
     95               
     96             

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   HEXtoBCD_LEFT
        6   -> update_string
      6   HEXtoBCD_RIGHT
        6   -> update_string
      4   adc_line4


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     122  HEXtoBCD_LEFT
     142  HEXtoBCD_RIGHT
       2  adc_line4
       1  hundreds
       1  ones
       1  tens
       1  thousands

 
 266 bytes in segment CODE
   4 bytes in segment DATA16_Z
 
 266 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
