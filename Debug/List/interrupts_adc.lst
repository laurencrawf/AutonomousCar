###############################################################################
#
# IAR C/C++ Compiler V7.12.3.989/W32 for MSP430           24/Apr/2020  12:34:17
# Copyright 1996-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.12
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\interrupts_adc.c
#    Command line  =  
#        -f C:\Users\laure\AppData\Local\Temp\EWEC8A.tmp
#        ("C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\interrupts_adc.c" -lC
#        "C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\List" -o
#        "C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --debug -D__MSP430FR2355__ -e --double=32
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\430\lib\dlib\dl430xlsfn.h" -I ./\ --core=430X --data_model=small
#        -On --multiplier=32 --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\List\interrupts_adc.lst
#    Object file   =  
#        C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code
#        Submission\Debug\Obj\interrupts_adc.r43
#
###############################################################################

C:\Users\laure\OneDrive\Documents\ECE_306_Code\Project 10 Code Submission\interrupts_adc.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the interrupts for the ADC Code
      4          //
      5          //
      6          //  Lauren Crawford
      7          //  02/28/2020
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
      9          //------------------------------------------------------------------------------
     10          
     11          #include  "functions.h"
     12          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x700
   \   union <unnamed> _A_ADCCTL0_L
   \                     _A_ADCCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x70a
   \   union <unnamed> _A_ADCMCTL0_L
   \                     _A_ADCMCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x712
   \   union <unnamed> _A_ADCMEM0_L
   \                     _A_ADCMEM0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x71e
   \   union <unnamed> _A_ADCIV_L
   \                     _A_ADCIV_L:
   \   000000                DS8 2
     13          #include <string.h>
     14          #include "macros.h"
     15          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile unsigned int ADC_Channel;
   \                     ADC_Channel:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          volatile unsigned int ADC_Left_Detect;
   \                     ADC_Left_Detect:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile unsigned int ADC_Right_Detect;
   \                     ADC_Right_Detect:
   \   000000                DS8 2
     19          extern volatile unsigned int ADC_Thumb;
     20          
     21          #pragma vector=ADC_VECTOR

   \                                 In  segment ISR_CODE, align 2
     22          __interrupt void ADC_ISR(void){
   \                     ADC_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
     23           switch(__even_in_range(ADCIV,ADCIV_ADCIFG)){
   \   000002   1F421E07     MOV.W   &0x71e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for ADC_ISR>_0`:
   \   000008   373C         JMP     ??ADC_ISR_1
   \   00000A   363C         JMP     ??ADC_ISR_1
   \   00000C   353C         JMP     ??ADC_ISR_1
   \   00000E   343C         JMP     ??ADC_ISR_1
   \   000010   333C         JMP     ??ADC_ISR_1
   \   000012   323C         JMP     ??ADC_ISR_1
   \   000014   003C         JMP     ??ADC_ISR_5
     24           case ADCIV_NONE:
     25           break;
     26           case ADCIV_ADCOVIFG: // When a conversion result is written to the ADCMEM0
     27           // before its previous conversion result was read.
     28           break;
     29           case ADCIV_ADCTOVIFG: // ADC conversion-time overflow
     30           break;
     31           case ADCIV_ADCHIIFG: // Window comparator interrupt flags
     32           break;
     33           case ADCIV_ADCLOIFG: // Window comparator interrupt flag
     34           break;
     35           case ADCIV_ADCINIFG: // Window comparator interrupt flag
     36           break;
     37           case ADCIV_ADCIFG: // ADCMEM0 memory register with the conversion result
     38             
     39           ADCCTL0 &= ~ADCENC; // Disable ENC bit.
   \                     ??ADC_ISR_5:
   \   000016   A2C30007     BIC.W   #0x2, &0x700
     40           switch (ADC_Channel++){
   \   00001A   1F42....     MOV.W   &ADC_Channel, R15
   \   00001E   0E4F         MOV.W   R15, R14
   \   000020   1E53         ADD.W   #0x1, R14
   \   000022   824E....     MOV.W   R14, &ADC_Channel
   \   000026   0F83         SUB.W   #0x0, R15
   \   000028   0424         JEQ     ??ADC_ISR_3
   \   00002A   1F83         SUB.W   #0x1, R15
   \   00002C   1024         JEQ     ??ADC_ISR_4
   \   00002E   1F83         SUB.W   #0x1, R15
   \   000030   1D3C         JMP     ??ADC_ISR_2
     41           case case0: // Channel A2 Interrupt
     42           ADCMCTL0 &= ~ADCINCH_2; // Disable Last channel A2
   \                     ??ADC_ISR_3:
   \   000032   A2C30A07     BIC.W   #0x2, &0x70a
     43           ADCMCTL0 |= ADCINCH_3; // Enable Next channel A3
   \   000036   B2D003000A07 BIS.W   #0x3, &0x70a
     44           ADC_Left_Detect = ADCMEM0; // Move result into Global
   \   00003C   92421207.... MOV.W   &0x712, &ADC_Left_Detect
     45          
     46           ADC_Left_Detect = ADC_Left_Detect >> 2; // Divide the result by 4
   \   000042   1F42....     MOV.W   &ADC_Left_Detect, R15
   \   000046   5F07         RRUM.W  #0x2, R15
   \   000048   824F....     MOV.W   R15, &ADC_Left_Detect
     47           //adc_line4(); // Place String in Display
     48           break;
   \   00004C   0F3C         JMP     ??ADC_ISR_2
     49           case case1:
     50             ADCMCTL0 &= ~ADCINCH_3; // Enable Next channel A3
   \                     ??ADC_ISR_4:
   \   00004E   B2F0FCFF0A07 AND.W   #0xfffc, &0x70a
     51           ADCMCTL0 |= ADCINCH_2; // Disable Last channel A2 
   \   000054   A2D30A07     BIS.W   #0x2, &0x70a
     52           ADC_Right_Detect = ADCMEM0; // Move result into Global
   \   000058   92421207.... MOV.W   &0x712, &ADC_Right_Detect
     53          
     54           ADC_Right_Detect = ADC_Right_Detect >> 2; // Divide the result by 4
   \   00005E   1F42....     MOV.W   &ADC_Right_Detect, R15
   \   000062   5F07         RRUM.W  #0x2, R15
   \   000064   824F....     MOV.W   R15, &ADC_Right_Detect
     55            ADC_Channel=0;
   \   000068   8243....     MOV.W   #0x0, &ADC_Channel
     56          
     57           break;
     58           case case2:
     59           //
     60          // ADC_Channel=0;
     61           break;
     62           default:
     63           break;
     64           }
     65           ADCCTL0 |= ADCENC; // Enable Conversions
   \                     ??ADC_ISR_2:
   \   00006C   A2D30007     BIS.W   #0x2, &0x700
     66           ADCCTL0 |= ADCSC;   
   \   000070   92D30007     BIS.W   #0x1, &0x700
     67             
     68           //ADC_Thumb = ADCMEM0; // Channel A5
     69           ADCCTL0 |= ADCSC; // Start next sample
   \   000074   92D30007     BIS.W   #0x1, &0x700
     70           default:
     71           break;
     72           }
     73          }
   \                     ??ADC_ISR_1:
   \   000078   1E17         POPM.W  #0x2, R15
   \   00007A   0013         RETI
   \   00007C                REQUIRE _A_ADCCTL0_L
   \   00007C                REQUIRE _A_ADCMCTL0_L
   \   00007C                REQUIRE _A_ADCMEM0_L
   \   00007C                REQUIRE _A_ADCIV_L

   \                                 In  segment INTVEC, offset 0x3a, root
   \                     `??ADC_ISR::??INTVEC 58`:
   \   00003A   ....         DC16    ADC_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   ADC_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ADC_Channel
     124  ADC_ISR
       2  ADC_ISR::??INTVEC 58
       2  ADC_Left_Detect
       2  ADC_Right_Detect
       2  _A_ADCCTL0_L
       2  _A_ADCIV_L
       2  _A_ADCMCTL0_L
       2  _A_ADCMEM0_L

 
   8 bytes in segment DATA16_AN
   6 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
 124 bytes in segment ISR_CODE
 
 124 bytes of CODE  memory
   0 bytes of CONST memory (+ 2 bytes shared)
   6 bytes of DATA  memory (+ 8 bytes shared)

Errors: none
Warnings: none
